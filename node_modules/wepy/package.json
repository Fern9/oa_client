{
  "_args": [
    [
      {
        "raw": "wepy",
        "scope": null,
        "escapedName": "wepy",
        "name": "wepy",
        "rawSpec": "",
        "spec": "latest",
        "type": "tag"
      },
      "/Users/cyh/PycharmProjects/wx_demo/myproject"
    ]
  ],
  "_cnpm_publish_time": 1495420412836,
  "_from": "wepy",
  "_hasShrinkwrap": false,
  "_id": "wepy@1.5.5",
  "_location": "/wepy",
  "_nodeVersion": "7.7.1",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/wepy-1.5.5.tgz_1495420412739_0.7591223362833261"
  },
  "_npmUser": {
    "name": "gcaufy",
    "email": "gcaufy@gmail.com"
  },
  "_npmVersion": "3.10.9",
  "_phantomChildren": {},
  "_requested": {
    "raw": "wepy",
    "scope": null,
    "escapedName": "wepy",
    "name": "wepy",
    "rawSpec": "",
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "http://registry.npm.taobao.org/wepy/download/wepy-1.5.5.tgz",
  "_shasum": "fee95a448b59f457b1ca192d38228acae7254c89",
  "_shrinkwrap": null,
  "_spec": "wepy",
  "_where": "/Users/cyh/PycharmProjects/wx_demo/myproject",
  "author": {
    "name": "Gcaufy"
  },
  "bugs": {
    "url": "https://github.com/wepyjs/wepy/issues"
  },
  "dependencies": {},
  "description": "[![npm version](https://badge.fury.io/js/wepy.svg)](https://badge.fury.io/js/wepy)\r [![travis-ci](https://travis-ci.org/wepyjs/wepy.svg?branch=master)](https://travis-ci.org/wepyjs/wepy)\r [![Coverage Status](https://coveralls.io/repos/github/wepyjs/wepy/badge.svg?branch=master)](https://coveralls.io/github/wepyjs/wepy?branch=master)\r [![Dependency Status](https://david-dm.org/wepyjs/wepy.svg)](https://david-dm.org/wepyjs/wepy)",
  "devDependencies": {
    "babel": "^6.5.2",
    "babel-cli": "^6.18.0",
    "babel-eslint": "^7.1.1",
    "babel-preset-es2015": "^6.18.0",
    "babel-preset-stage-1": "^6.16.0"
  },
  "directories": {},
  "dist": {
    "shasum": "fee95a448b59f457b1ca192d38228acae7254c89",
    "size": 19549,
    "noattachment": false,
    "tarball": "http://registry.npm.taobao.org/wepy/download/wepy-1.5.5.tgz"
  },
  "homepage": "https://github.com/wepyjs/wepy#readme",
  "license": "ISC",
  "main": "lib/wepy.js",
  "maintainers": [
    {
      "name": "gcaufy",
      "email": "gcaufy@gmail.com"
    }
  ],
  "name": "wepy",
  "optionalDependencies": {},
  "publish_time": 1495420412836,
  "readme": "# 小程序框架wepy文档\r\n\r\n[![npm version](https://badge.fury.io/js/wepy.svg)](https://badge.fury.io/js/wepy)\r\n[![travis-ci](https://travis-ci.org/wepyjs/wepy.svg?branch=master)](https://travis-ci.org/wepyjs/wepy)\r\n[![Coverage Status](https://coveralls.io/repos/github/wepyjs/wepy/badge.svg?branch=master)](https://coveralls.io/github/wepyjs/wepy?branch=master)\r\n[![Dependency Status](https://david-dm.org/wepyjs/wepy.svg)](https://david-dm.org/wepyjs/wepy)\r\n\r\n\r\n![wepy_group](https://cloud.githubusercontent.com/assets/2182004/21045917/35ffc6ac-be3d-11e6-8387-d8eb3f737b71.jpg)\r\n\r\n扫码加入wepyjs体验交流群。\r\n\r\n[点此查看CHANGELOG](https://github.com/wepyjs/wepy/blob/master/CHANGELOG.md)\r\n\r\n## 快速入门\r\n\r\n### 项目创建与使用\r\n\r\n#### 安装wepy\r\n以下安装都通过`npm`安装\r\n\r\n安装 wepy 命令行工具。\r\n \r\n```bash\r\nnpm install wepy-cli -g\r\n```\r\n\r\n在开发目录生成开发DEMO。\r\n \r\n```bash\r\nwepy new myproject\r\n```\r\n\r\n切换至项目目录。\r\n\r\n```bash\r\ncd myproject\r\n```\r\n\r\n开发实时编译。\r\n\r\n```bash\r\nwepy build --watch\r\n```\r\n#### 项目目录结构\r\n```\r\n    dist\r\n    node_modules\r\n    src\r\n        components\r\n            com_a.wpy\r\n            com_b.wpy\r\n        pages\r\n            index.wpy\r\n            page2.wpy\r\n        app.wpy\r\n    package.json\r\n```\r\n\r\n#### 开发使用说明\r\n1. 使用`微信开发者工具`新建项目，本地开发选择`dist`目录。\r\n2. `微信开发者工具` --> 项目 --> 关闭ES6转ES5。\r\n3. 本地项目根目录运行`wepy build --watch`，开启实时编译。\r\n\r\n\r\n###代码规范：\r\n1. 变量与方法使用尽量使用驼峰式命名，避免使用`$`开头。\r\n以`$`开头的方法或者属性为框架内建方法或者属性，可以被使用，使用前请[参考API文档](#api)。\r\n2. 入口，页面，组件的命名后缀为`.wpy`。外链的文件可以是其它后缀。\r\n请参考[wpy文件说明](#wpy文件说明)\r\n3. 使用ES6语法开发。\r\n框架在ES6下开发，因此也需要使用ES6开发小程序，ES6中有大量的语法糖可以让我们的代码更加简洁高效。\r\n4. 使用Promise\r\n框架默认对小程序提供的API全都进行了 Promise 处理，甚至可以直接使用`async/await`等新特性进行开发。\r\n\r\n\r\n## 主要解决问题：\r\n### 1. 开发模式转换\r\n在原有的小程序的开发模式下进行再次封装，更贴近于现有MVVM框架开发模式。框架在开发过程中参考了一些现在框架的一些特性，并且融入其中，以下是使用wepy前后的代码对比图。\r\n\r\n官方DEMO代码：\r\n```javascript\r\n//index.js\r\n//获取应用实例\r\nvar app = getApp()\r\nPage({\r\n  data: {\r\n    motto: 'Hello World',\r\n    userInfo: {}\r\n  },\r\n  //事件处理函数\r\n  bindViewTap: function() {\r\n    console.log('button clicked')\r\n  },\r\n  onLoad: function () {\r\n    console.log('onLoad')\r\n  }\r\n})\r\n```\r\n\r\n基于wepy的实现：\r\n```javascript\r\nimport wepy from 'wepy';\r\n\r\nexport default class Index extends wepy.page {\r\n\r\n    data = {\r\n        motto: 'Hello World',\r\n        userInfo: {}\r\n    };\r\n    methods = {\r\n        bindViewTap () {\r\n            console.log('button clicked');\r\n        }\r\n    };\r\n    onLoad() {\r\n        console.log('onLoad');\r\n    };\r\n}\r\n```\r\n### 2. 支持组件化开发。\r\n\r\n参见章节：[组件](#组件)\r\n示例代码：\r\n```html\r\n// index.wpy\r\n<template>\r\n    <view>\r\n        <component id=\"pannel\" path=\"pannel\"></component>\r\n        <component id=\"counter1\" path=\"counter\"></component>\r\n        <component id=\"counter2\" path=\"counter\"></component>\r\n        <component id=\"list\" path=\"list\"></component>\r\n    </view>\r\n</template>\r\n<script>\r\nimport wepy from 'wepy';\r\nimport List from '../components/list';\r\nimport Panel from '../components/panel';\r\nimport Counter from '../components/counter';\r\n\r\nexport default class Index extends wepy.page {\r\n\r\n    config = {\r\n        \"navigationBarTitleText\": \"test\"\r\n    };\r\n    components = {\r\n        panel: Panel,\r\n        counter1: Counter,\r\n        counter2: Counter,\r\n        list: List\r\n    };\r\n}\r\n</script>\r\n```\r\n\r\n### 3. 支持加载外部NPM包。\r\n\r\n在编译过程当中，会递归遍历代码中的`require`然后将对应依赖文件从node_modules当中拷贝出来，并且修改`require`为相对路径，从而实现对外部NPM包的支持。如下图：\r\n\r\n![npm](https://cloud.githubusercontent.com/assets/2182004/20554645/482b0f64-b198-11e6-8d4e-70c92326004f.png)\r\n\r\n### 4. 单文件模式，使得目录结构更加清晰。\r\n\r\n[官方目录结构](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/structure.html?t=20161107)要求app必须有三个文件`app.json`，`app.js`，`app.wxss`，页面有4个文件 `index.json`，`index.js`，`index.wxml`，`index.wxss`。而且文件必须同名。\r\n所以使用wepy开发前后开发目录对比如下：\r\n官方DEMO：\r\n```\r\nproject\r\n    pages\r\n        index\r\n            index.json\r\n            index.js\r\n            index.wxml\r\n            index.wxss\r\n        log\r\n            log.json\r\n            log.wxml\r\n            log.js\r\n            log.wxss\r\n    app.js\r\n    app.json\r\n    app.wxss\r\n```\r\n使用wepy框架后目录结构：\r\n```\r\nproject\r\n    src\r\n        pages\r\n            index.wpy\r\n            log.wpy\r\n        app.wpy\r\n```\r\n\r\n### 5. 默认使用babel编译，支持ES6/7的一些新特性。\r\n\r\n用户可以通过修改`wepy.config.js`(老版本使用`.wepyrc`)配置文件，配置自己熟悉的babel环境进行开发。默认开启使用了一些新的特性如`promise`，`async/await`等等。\r\n\r\n示例代码：\r\n```javascript\r\nimport wepy from 'wepy';\r\n\r\nexport default class Index extends wepy.page {\r\n\r\n    getData() {\r\n        return new Promise((resolve, reject) => {\r\n            setTimeout(() => {\r\n                resolve({data: 123});\r\n            }, 3000);\r\n        });\r\n    };\r\n    async onLoad() {\r\n        let data = await this.getData();\r\n        console.log(data.data);\r\n    };\r\n}\r\n```\r\n### 6. 针对原生API进行优化。\r\n\r\n对现在API进行promise处理，同时修复一些现有API的缺陷，比如：wx.request并发问题等。\r\n原有代码：\r\n```javascript\r\nonLoad = function () {\r\n    var self = this;\r\n    wx.login({\r\n        success: function (data) {\r\n            wx.getUserInfo({\r\n                success: function (userinfo) {\r\n                    self.setData({userInfo: userinfo});\r\n                }\r\n            });\r\n        }\r\n    });\r\n}\r\n```\r\n基于wepy实现代码：\r\n```javascript\r\nasync onLoad() {\r\n    await wx.login();\r\n    this.userInfo = await wx.getUserInfo();\r\n}\r\n```\r\n\r\n在同时并发10个request请求测试时：\r\n不使用wepy:\r\n\r\n![2 small](https://cloud.githubusercontent.com/assets/2182004/20554651/5185f740-b198-11e6-88f8-45e359090dc3.png)\r\n![3 small](https://cloud.githubusercontent.com/assets/2182004/20554886/c30e802a-b199-11e6-927d-08cd4e5ed0b0.png)\r\n\r\n使用wepy后：\r\n\r\n![4 small](https://cloud.githubusercontent.com/assets/2182004/20554663/65704c2e-b198-11e6-8277-abb77e0c7b3e.png)\r\n\r\n\r\n\r\n## 进阶说明\r\n\r\n### wepy.config.js 配置文件说明\r\n执行`wepy new demo`后，会生成类似配置文件。\r\n```javascript\r\nlet prod = process.env.NODE_ENV === 'production';\r\n\r\nmodule.exports = {\r\n  \"wpyExt\": \".wpy\",\r\n  \"babel\": {\r\n    \"presets\": [\r\n      \"es2015\",\r\n      \"stage-1\"\r\n    ],\r\n    \"plugins\": [\r\n      \"transform-export-extensions\",\r\n      \"syntax-export-extensions\",\r\n      \"transform-runtime\"\r\n    ]\r\n  }\r\n};\r\n\r\n\r\nif (prod) {\r\n  // 压缩sass\r\n  module.exports['sass'] = {\"outputStyle\": \"compressed\"};\r\n  \r\n  // 压缩less\r\n  module.exports['less'] = {\"compress\": true};\r\n\r\n  // 压缩js\r\n  module.exports.plugins = {\r\n      'UglifyJsPlugin': {\r\n          filter: /\\.js$/,\r\n          config: {\r\n              compress: {\r\n                warning: false\r\n              }\r\n          }\r\n      },\r\n      'TestPlugin': {\r\n          filter: /\\.wxml$/,\r\n          config: {\r\n          }\r\n      }\r\n  };\r\n}\r\n\r\n```\r\n\r\n**wpyExt：**缺省值为'.wpy'，IDE默认情况下不会对此文件类型高亮，此时可以修改所有文件为`.vue`后缀(因为与vue高亮规则一样)，然后将此选项修改为`.vue`，就能解决部分IDE代码高亮问题。\r\n\r\n**sass：**sass编译配置，参见[这里](https://github.com/sass/node-sass)。\r\n\r\n**less：**less编译配置，参见[这里](http://lesscss.org/#using-less-usage-in-code)。\r\n\r\n**babel：**babel编译配置，参见[这里](http://babeljs.io/docs/usage/options/)。\r\n\r\n**plugins：** plugins为`1.1.6`版本之后功能，目前支持js压缩与图片压缩，持续开发...\r\n\r\n\r\n### wpy文件说明\r\n`wpy`文件的编译过程过下：\r\n\r\n![5 small](https://cloud.githubusercontent.com/assets/2182004/20554671/70a797a0-b198-11e6-8355-b7c234713d0c.png)\r\n\r\n一个`.wpy`文件分为三个部分：\r\n\r\n1. 样式`<style></style>`对应原有`wxss`。\r\n2. 模板`<template></template>`对应原有`wxml`。\r\n3. 代码`<script></script>`对应原有`js`。\r\n\r\n其中入口文件`app.wpy`不需要`template`，所以编译时会被忽略。这三个标签都支持`type`和`src`属性，`type`决定了其代码编译过程，`src`决定是否外联代码，存在`src`属性且有效时，忽略内联代码，示例如下：\r\n```\r\n<style type=\"less\" src=\"page1.less\"></style>\r\n<template type=\"wxml\" src=\"page1.wxml\"></template>\r\n<script>\r\n    // some code\r\n</script>\r\n```\r\n标签对应 `type` 值如下表所示：\r\n\r\n| 标签 | type默认值 | type支持值 |\r\n| ---- | ---- | ---- |\r\n|style|`css`|`css`，`less`，`sass（待完成）`|\r\n|template|`wxml`|`wxml`，`xml`，`html（待完成）`|\r\n|script|`js`|`js`，`TypeScript(待完成)`|\r\n\r\n### script说明\r\n\r\n#### 程序入口app.wpy\r\n```\r\n<style type=\"less\">\r\n/** less **/\r\n</style>\r\n<script>\r\nimport wepy from 'wepy';\r\nexport default class extends wepy.app {\r\n    config = {\r\n            \"pages\":[\r\n            \"pages/index/index\"\r\n        ],\r\n        \"window\":{\r\n            \"backgroundTextStyle\": \"light\",\r\n            \"navigationBarBackgroundColor\": \"#fff\",\r\n            \"navigationBarTitleText\": \"WeChat\",\r\n            \"navigationBarTextStyle\": \"black\"\r\n        }\r\n    };\r\n    onLaunch() {\r\n        console.log(this);\r\n    }\r\n}\r\n</script>\r\n```\r\n入口`app.wpy`继承自`wepy.app`，包含一个`config`属性和其全局属性、方法、事件。其中`config`属性对应原有的`app.json`，编译时会根据`config`生成`app.json`文件，如果需要修改`config`中的内容，请使用系统提供API。\r\n\r\n#### 页面index.wpy\r\n```\r\n<style type=\"less\">\r\n/** less **/\r\n</style>\r\n<template type=\"wxml\">\r\n    <view>\r\n    </view>\r\n    <component id=\"counter1\" path=\"counter\"></component>\r\n</template>\r\n<script>\r\nimport wepy form 'wepy';\r\nimport Counter from '../components/counter';\r\nexport default class Index extends wepy.page {\r\n\r\n    config = {};\r\n    components = {counter1: Counter};\r\n\r\n    data = {};\r\n    methods = {};\r\n\r\n    events = {};\r\n    onLoad() {};\r\n    // Other properties\r\n}\r\n</script>\r\n```\r\n页面入口继承自`wepy.page`，主要属性说明如下：\r\n\r\n| 属性 | 说明 |\r\n| ---- | ---- |\r\n|config|页面config，相当于原来的index.json，同`app.wpy`中的config|\r\n|components|页面引入的组件列表|\r\n|data|页面需要渲染的数据|\r\n|methods|wmxl的事件捕捉，如`bindtap`，`bindchange`|\r\n|events|组件之间通过`broadcast`，`emit`传递的事件|\r\n|其它|如`onLoad`，`onReady`等小程序事件以及其它自定义方法与属性|\r\n\r\n#### 组件com.wpy\r\n```\r\n<style type=\"less\">\r\n/** less **/\r\n</style>\r\n<template type=\"wxml\">\r\n    <view>  </view>\r\n</template>\r\n<script>\r\nimport wepy form 'wepy';\r\nexport default class Com extends wepy.component {\r\n\r\n    components = {};\r\n\r\n    data = {};\r\n    methods = {};\r\n\r\n    events = {};\r\n    // Other properties\r\n}\r\n</script>\r\n```\r\n页面入口继承自`wepy.component`，属性与页面属性一样，除了不需要`config`以及页面特有的一些小程序事件等等。\r\n\r\n### 组件\r\n小程序支持js[模块化](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/module.html?t=20161107)引用，也支持[wxml模板](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/template.html?t=20161107)，但彼此独立，业务代码与交互事件仍需在页面处理。无法实现组件化的松耦合与复用的效果。\r\n例如模板A中绑定一个`bindtap=\"myclick\"`，模板B中同样绑定一样`bindtap=\"myclick\"`，那么就会影响同一个页面事件。对于数据同样如此。因此只有通过改变变量或者事件方法，或者给其加不同前缀才能实现绑定不同事件或者不同数据。当页面复杂之后就十分不利于开发维护。\r\n因此wepy让小程序支持组件化开发，组件的所有业务与功能在组件本身实现，组件与组件之间彼此隔离，上述例子在wepy的组件化开发过程中，A组件只会影响到A绑定的`myclick`，B也如此。\r\n\r\n#### 组件引用\r\n当页面或者组件需要引入子组件时，需要在页面或者`script`中的`components`给组件分配唯一id，并且在`template`中添加`<component>`标签，如[index.wpy](页面index.wpy)。\r\n\r\n页面和组件都可以引入子组件，引入若干组件后，如下图：\r\n\r\n![6 small](https://cloud.githubusercontent.com/assets/2182004/20554681/796da1ae-b198-11e6-91ab-e90f485c594d.png)\r\n\r\nIndex页面引入A，B，C三个组件，同时组件A和B又有自己的子组件D，E，F，G，H。\r\n\r\n#### 组件通信与交互\r\n`wepy.component`基类提供三个方法`$broadcast`，`$emit`，`$invoke`，因此任一页面或任一组件都可以调用上述三种方法实现通信与交互，如：\r\n```\r\n$this.$emit('some-event', 1, 2, 3, 4);\r\n```\r\n\r\n组件的事件监听需要写在`events`属性下，如：\r\n```javascript\r\nimport wepy form 'wepy';\r\nexport default class Com extends wepy.component {\r\n\r\n    components = {};\r\n\r\n    data = {};\r\n    methods = {};\r\n\r\n    events = {\r\n        'some-event': ($event, ...args) {\r\n               console.log(`${this.name} receive ${$event.name} from ${$event.source.name}`);\r\n        }\r\n    };\r\n    // Other properties\r\n}\r\n```\r\n1. **$broadcast**\r\n`$broadcast`事件是由父组件发起，所有子组件都会收到此广播事件，除非事件被手动取消。事件广播的顺序为广度优先搜索顺序，如上图，如果`Page_Index`发起一个`$broadcast`事件，那么接收到事件的先后顺序为：A, B, C, D, E, F, G, H。如下图：\r\n\r\n![7 small](https://cloud.githubusercontent.com/assets/2182004/20554688/800089e6-b198-11e6-84c5-352d2d0e2f7e.png)\r\n\r\n\r\n2. **$emit**\r\n`$emit`与`$broadcast`正好相反，事件发起组件的父组件会依次接收到`$emit`事件，如上图，如果E发起一个`$emit`事件，那么接收到事件的先后顺序为：A, Page_Index。如下图：\r\n\r\n![8 small](https://cloud.githubusercontent.com/assets/2182004/20554704/9997932c-b198-11e6-9840-3edae2194f47.png)\r\n\r\n\r\n3. **$invoke**\r\n`$invoke`是一个组件对另一个组件的直接调用，通过传入的组件路径找到相应组件，然后再调用其方法。\r\n如果想在`Page_Index`中调用组件A的某个方法：\r\n```\r\nthis.$invoke('ComA', 'someMethod', 'someArgs');\r\n```\r\n如果想在组件A中调用组件G的某个方法：\r\n```\r\nthis.$invoke('./../ComB/ComG', 'someMethod', 'someArgs');\r\n```\r\n\r\n\r\n### 第三方组件\r\n\r\nwepyjs 允许使用基于wepyjs开发的第三方组件，开发第三方组件规范请参考[wepy-com-toast](https://github.com/wepyjs/wepy-com-toast)。\r\n\r\n\r\n### 混合\r\n\r\n混合可以将组之间的可复用部分抽离，从而在组件中使用混合时，可以将混合的数据，事件以及方法注入到组件之中。混合分分为两种：\r\n\r\n* 默认式混合\r\n* 兼容式混合\r\n\r\n#### 默认式混合\r\n\r\n对于组件`data`数据，`components`组件，`events`事件以及其它自定义方法采用**默认式混合**，即如果组件未声明该数据，组件，事件，自定义方法等，那么将混合对象中的选项将注入组件这中。对于组件已声明的选项将不受影响。\r\n```\r\n// mixins/test.js\r\nimport wepy from 'wepy';\r\n\r\nexport default class TestMixin extends wepy.page {\r\n    data = {\r\n        foo: 'foo defined by page',\r\n        bar: 'bar defined by testMix'\r\n    };\r\n    methods: {\r\n    tap () {\r\n      console.log('mix tap');\r\n    }\r\n  }\r\n}\r\n\r\n// pages/index.wpy\r\nimport wepy from 'wepy';\r\nimport TestMixin from './mixins/test';\r\n\r\nexport default class Index extends wepy.mixin {\r\n    data = {\r\n        foo: 'foo defined by index'\r\n    };\r\n    mixins = [TestMixin ];\r\n    onShow() {\r\n    console.log(this.foo); // foo defined by index.\r\n    console.log(this.bar); // foo defined by testMix.\r\n  }\r\n}\r\n```\r\n\r\n\r\n#### 兼容式混合\r\n\r\n对于组件`methods`响应事件，以及小程序页面事件将采用**兼容式混合**，即先响应组件本身响应事件，然后再响应混合对象中响应事件。\r\n\r\n```\r\n// mixins/test.js\r\nimport wepy from 'wepy';\r\n\r\nexport default class TestMixin extends wepy.page {\r\n    methods = {\r\n    tap () {\r\n      console.log('mix tap');\r\n    }\r\n  };\r\n    onShow() {\r\n    console.log('mix onshow');\r\n  }\r\n}\r\n\r\n// pages/index.wpy\r\nimport wepy from 'wepy';\r\nimport TestMixin from './mixins/test';\r\n\r\nexport default class Index extends wepy.mixin {\r\n\r\n    mixins = [TestMixin];\r\n    methods = {\r\n    tap () {\r\n      console.log('index tap');\r\n    }\r\n  };\r\n    onShow() {\r\n    console.log('index onshow');\r\n  }\r\n}\r\n\r\n\r\n// index onshow\r\n// mix onshow\r\n// ----- when tap\r\n// index tap\r\n// mix tap\r\n```\r\n\r\n### 数据绑定\r\n\r\n#### 小程序数据绑定方式\r\n小程序通过`Page`提供的`setData`方法去绑定数据，如：\r\n```\r\nthis.setData({title: 'this is title'});\r\n```\r\n因为小程序架构本身原因，页面渲染层和JS逻辑层分开的，setData操作实际就是JS逻辑层与页面渲染层之间的通信，那么如果在同一次运行周期内多次执行`setData`操作时，那么通信的次数是一次还是多次呢？这个取决于API本身的设计。\r\n\r\n#### wepy数据绑定方式\r\nwepy使用脏数据检查对setData进行封装，在函数运行周期结束时执行脏数据检查，一来可以不用关心页面多次setData是否会有性能上的问题，二来可以更加简洁去修改数据实现绑定，不用重复去写setData方法。代码如下：\r\n```javascript\r\nthis.title = 'this is title';\r\n```\r\n但需注意，在函数运行周期之外的函数里去修改数据需要手动调用`$apply`方法。如：\r\n```javascript\r\nsetTimeout(() => {\r\n    this.title = 'this is title';\r\n    this.$apply();\r\n}, 3000);\r\n```\r\n\r\n#### wepy脏数据检查流程\r\n在执行脏数据检查是，会通过`this.$$phase`标识当前检查状态，并且会保证在并发的流程当中，只会有一个脏数据检查流程在运行，以下是执行脏数据检查的流程图：\r\n\r\n![9 small](https://cloud.githubusercontent.com/assets/2182004/20554709/a0d8b1e8-b198-11e6-9034-0997b33bdf95.png)\r\n\r\n### 其它优化细节\r\n\r\n#### 1. wx.request 接收参数修改\r\n点这里查看[官方文档](https://mp.weixin.qq.com/debug/wxadoc/dev/api/network-request.html?t=20161122)\r\n```javascript\r\n// 官方\r\nwx.request({\r\n    url: 'xxx',\r\n    success: function (data) {\r\n        console.log(data);\r\n    }\r\n});\r\n\r\n// wepy 使用方式\r\n// request 接口从只接收Object变为可接收String\r\nwx.request('xxxx').then((d) => console.log(d));\r\n```\r\n\r\n#### 2. 优化事件参数传递\r\n点这里查看[官方文档](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/event.html?t=20161122)\r\n```javascript\r\n// 官方\r\n<view data-id=\"{{index}}\" data-title=\"wepy\" data-other=\"otherparams\" bindtap=\"tapName\"> Click me! </view>\r\nPage({\r\n  tapName: function(event) {\r\n    console.log(event.currentTarget.dataset.id)// output: 1\r\n    console.log(event.currentTarget.dataset.title)// output: wepy\r\n    console.log(event.currentTarget.dataset.other)// output: otherparams\r\n  }\r\n});\r\n\r\n// wepy 建议传参方式\r\n<view data-wepy-params=\"{{index}}-wepy-otherparams\" bindtap=\"tapName\"> Click me! </view>\r\n\r\nevents: {\r\n  tapName (event, id, title, other) {\r\n    console.log(id, title, other)// output: 1, wepy, otherparams\r\n  }\r\n}\r\n\r\n// wepy 1.1.8以后的版本，只允许传string。\r\n<view bindtap=\"tapName({{index}}, 'wepy', 'otherparams')\"> Click me! </view>\r\n\r\nevents: {\r\n  tapName (event, id, title, other) {\r\n    console.log(id, title, other)// output: 1, wepy, otherparams\r\n  }\r\n}\r\n```\r\n\r\n#### 3. 改变数据绑定方式\r\n保留setData方法，但不建议使用setData执行绑定，修复传入`undefined`的bug，并且修改入参支持：\r\n`this.setData(target, value)`\r\n`this.setData(object)`\r\n\r\n点这里查看[官方文档](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/template.html?t=20161122)\r\n```\r\n// 官方\r\n<view> {{ message }} </view>\r\n\r\nonLoad: function () {\r\n    this.setData({message: 'hello world'});\r\n}\r\n\r\n\r\n// wepy\r\n<view> {{ message }} </view>\r\n\r\nonLoad () {\r\n    this.message = 'hello world';\r\n}\r\n```\r\n\r\n#### 4. 组件代替模板和模块\r\n\r\n点这里查看[官方文档](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/data.html?t=20161122)\r\n```\r\n// 官方\r\n<!-- item.wxml -->\r\n<template name=\"item\">\r\n  <text>{{text}}</text>\r\n</template>\r\n\r\n<!-- index.wxml -->\r\n<import src=\"item.wxml\"/>\r\n<template is=\"item\" data=\"{{text: 'forbar'}}\"/>\r\n\r\n<!-- index.js -->\r\nvar item = require('item.js')\r\n\r\n\r\n\r\n\r\n// wepy\r\n<!-- /components/item.wpy -->\r\n <text>{{text}}</text>\r\n\r\n<!-- index.wpy -->\r\n<template>\r\n    <component id=\"item\"></component>\r\n</template>\r\n<script>\r\n    import wepy from 'wepy';\r\n    import Item from '../components/item';\r\n    export default class Index extends wepy.page {\r\n        components = { Item }\r\n    }\r\n</script>\r\n\r\n```\r\n\r\n## API\r\n\r\n### wepy.event\r\n\r\n|父类 | 无 |\r\n| ---- | ---- | \r\n\r\n| 属性 | 类型 | 默认值 | 说明 |\r\n| ---- | ---- | ---- | ---- |\r\n| name | String | - | 事件名称 |\r\n| source | wepy.component | - | 事件来源 |\r\n| type | String | - | emit 或者 broadcast |\r\n\r\n| 方法 | 参数 | 返回值 | 说明|\r\n| ---- | ---- | ---- | ---- |\r\n| destroy | - | - | 在 emit 或者 broadcast 过程中，调用destroy方法将会停止事件传播。|\r\n\r\n### wepy.component\r\n\r\n|父类 | 无 |\r\n| ---- | ---- |\r\n\r\n| 属性 | 类型 | 默认值 | 说明 |\r\n| ---- | ---- | ---- | ---- |\r\n| isComponent | Boolean | true | 是否是组件，如果是页面，此值为false |\r\n| prefix | String | '' | 组件前缀，组件前缀+组件方法属性才是在小程序中真实存在的方法或属性。 |\r\n| $root | wepy.page | - | 根组件，一般都是页面 |\r\n| $parent | wepy.component | - | 父组件 |\r\n| $wxpage | Page | - | 小程序Page对象 |\r\n| $coms | List(wepy.component) | {} | 子组件列表 |\r\n\r\n| 方法 | 参数 | 返回值 | 说明|\r\n| ---- | ---- | ---- | ---- |\r\n| init | - | - | 组件初始化。|\r\n| getWxPage | - | Page | 返回小程序Page对象。|\r\n| $getComponent | path(String) | wepy.component | 通过组件路径返回组件对象。|\r\n| $invoke | com(String/wepy.component), method(String), [args] | - | 调用其它组件方法 |\r\n| $broadcast | evtName(String), [args] | - | broadcast事件。|\r\n| $emit | evtName(String), [args] | - | emit事件。|\r\n| $apply | fn(Function) | - | 准备执行脏数据检查。|\r\n| $digest | - | - | 脏检查。|\r\n### wepy.page\r\n\r\n|父类 | wepy.component |\r\n| ---- | ---- |\r\n\r\n| 属性 | 类型 | 默认值 | 说明 |\r\n| ---- | ---- | ---- | ---- |\r\n\r\n| 方法 | 参数 | 返回值 | 说明|\r\n| ---- | ---- | ---- | ---- |\r\n| init | - | - | 页面始化。|\r\n\r\n### wepy.app\r\n\r\n|父类 | 无 |\r\n| ---- | ---- |\r\n\r\n| 属性 | 类型 | 默认值 | 说明 |\r\n| ---- | ---- | ---- | ---- |\r\n|$wxapp|App|-|小程序getApp()|\r\n| init | - | - | 应用始化包括对原生API的改造与优化|\r\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/wepyjs/wepy.git"
  },
  "scripts": {
    "build": "babel --presets es2015,stage-1 src/ --out-dir lib/ --source-maps",
    "eslint": "eslint src/",
    "prepublish": "npm run build",
    "test": "npm run eslint && npm run test-cov",
    "test-cov": "istanbul cover ./node_modules/mocha/bin/_mocha -- -t 50000 --recursive  -R spec test/",
    "watch": "npm run watch-compile",
    "watch-compile": "npm run build -- --watch"
  },
  "version": "1.5.5"
}
